
\documentclass[a4paper,twoside]{article}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}
\usepackage{graphicx}
\usepackage{booktabs,chemformula}
\usepackage{SCITEPRESS}     % Please add other packages that you may need BEFORE the SCITEPRESS.sty package.

\graphicspath{ {images/} }
\begin{document}

\title{Identifying logical dependencies from co-changing classes}


\author{\authorname{blind for review} %Adelina Diana Stana, Ioana \c{S}ora}
%\affiliation{
%Department of Computer and Information Technology, \\ Politehnica University Timisoara, Romania}
}



\keywords{software evolution, logical dependencies, structural dependencies}

\abstract{
Emerging software engineering approaches support the idea that logical dependencies should be included next to structural dependencies in general methods and tools for dependency management.  However, logical dependencies are still hard to identify, as not all co-changes during the system evolution represent true logical dependencies. Our work identifies a set of factors that can be used to filter the recordings of class co-changes in order to find logical dependencies.Also we analyze the quantitative relationships between the sets of logical and structural dependencies and their intersection and differences because we believe that a part of structural dependencies should have corresponding logical dependencies in the versioning system. We present results obtained through an experimental study on a set of 
open source software projects with their historical evolution. Identifying logical dependencies from co-changing classes will enhance dependency models used in various software analysis activities.
}

\onecolumn \maketitle \normalsize \setcounter{footnote}{0} \vfill



\section{Introduction}
\label{sec:intro}

Coupling reflects the degree of interdependence between different software modules, being a measure of how closely connected they are. Coupling should be low in order to ensure the testability, reusability, and evolvability properties of modules.The traditional approach on coupling was to quantify the structural dependencies or interactions between modules which both can be determined by source code analysis
   
Modules may present different kinds and degrees of interdependence, even if no structural dependencies can be found by analyzing the source code. Gall \cite{Gall:1998:DLC:850947.853338} identified as logical coupling between two modules the fact that these modules repeatedly change together during the historical evolution of the software system. This can be an indicator of a logical dependency between these modules.

The concepts of logical coupling and logical dependencies were first used in different analysis tasks, all related to changes: for software change impact analysis \cite{1553643}, for identifying the potential ripple effects caused by software changes during software maintenance and evolution \cite{DBLP:conf/issre/OlivaG15}, \cite{Oliva:2011:ISL:2067853.2068086}, \cite{Poshyvanyk2009}, \cite{posh2010} or for their link to deffects \cite{wiese}, \cite{Zimmermann:2004:MVH:998675.999460}.

The current trend recommends that general dependency management methods and tools should also include logical dependencies besides the structural dependencies \cite{Oliva:2011:ISL:2067853.2068086}, \cite{DBLP:journals/jss/AjienkaC17}. Different applications based on dependency analysis could be improved if, beyond structural dependencies, they also take into account the hidden non-structural dependencies. For example, works  which investigate different methods for architectural reconstruction \cite{SoraConti}, \cite{SoraSem13}, \cite{PagerankENASE},  all of them based on the information provided by structural dependencies, could enrich their dependency models by taking into account also logical dependencies. However, a thorough survey \cite{sar} shows that historical information has been rarely used in architectural reconstruction. Another survey \cite{Shtern:2012:CMS:2332427.2332428} mentions one possible explanation why historical information have been rarely used in architectural reconstruction: the size of the extracted information. The problem is not only the size of the extraction process, which has to analyze many versions from the historical evolution of the system, but also the number of the logical dependencies and how they relate to the number of structural dependencies. Logical dependencies should integrate harmonious with structural dependencies in a unitary dependency model: valuable logical dependencies should not be omitted from the dependency model, but structural dependencies should not be engulfed by questionable logical dependencies.  
Thus, in order to add logical dependencies besides structural dependencies in dependency models, class co-changes must be filtered until they remain only a reduced but relevant set of true logical dependencies. 


In the next section we analyze the state of the art results for determining logical dependencies from the point of view of their quantitative relationship with structural dependencies. Starting from this analysis, in Section \ref{sec:question} we identify a set of factors that can be used to filter the recordings of class co-changes such that logical dependencies are identified and formulate the research questions. In order to answer these research questions, we have built a tool that extracts structural and logical dependencies in different scenarios. The design and implementation of the tool is briefly presented in section \ref{sec:tool}. We have analyzed several open-source software systems of different sizes with our tool, obtaining the experimental results presented in Section \ref{sec:experiments}. Section \ref{sec:discussion} discusses the experimental results and answers the research questions. Threats to validity and future work directions are identified in Section \ref{sec:validity}.
 


\section{State of the art}
\label{sec:state}


There are researches that investigated quantitative aspects of logical dependencies and their interplay with structural dependencies. 
Oliva and Gerosa \cite{Oliva:2011:ISL:2067853.2068086}, \cite{DBLP:conf/issre/OlivaG15} have found first that the set of co-changed classes was much larger compared to the set of structurally coupled classes. They identified structural and logical dependencies from 150000 revisions from the Apache Software Foundation SVN repository. Also they concluded  that in at least 91\% of the cases, logical dependencies involve files that are not structurally related. This implies that not all of the change dependencies are related to structural dependencies and there could be other reasons for software artifacts to be change dependent.

Ajienka and Capiluppi also studied the interplay between logical and structural coupling of software classes. In \cite{DBLP:journals/jss/AjienkaC17} they  perform experiments on 79 open source systems: for each system, they determine the sets of structural dependencies, the set of logical dependencies and the intersections of these sets. They quantify the overlapping or intersection of these sets, coming to the conclusion that not all co-changed class pairs (classes with logical dependencies) are also linked by structural dependencies. One other interesting aspect which has not been investigated by the authors in \cite{DBLP:journals/jss/AjienkaC17}  is the total number of logical dependencies, reported to the total number of structural dependencies of a software systems. However, they provide the raw data of their measurements and we calculated the ratio between the number of logical dependencies and the number of structural dependencies for all the projects analyzed by them: the average ratio resulted 12.  This means that, using their method of detecting logical dependencies for a system, the number of logical dependencies outnumbers by one order of magnitude the number of structural dependencies. 


Another kind of non-structural dependencies are the semantic or conceptual dependencies \cite{Poshyvanyk2009}, \cite{posh2010}. Semantic coupling is given by the degree to which the identifiers
and comments from different classes are similar to each other. Semantic coupling could be an indicator for logical dependencies, as studied by Ajienka et al in \cite{DBLP:journals/ese/AjienkaCC18}. The experiments showed that a large number of co-evolving classes do not present semantic coupling, adding to the earlier research which showed that a large number of co-evolving classes do not present structural coupling. All these experimental findings rise the question whether it is a legitimate approach to accept all co-evolving classes as logical coupling.


Changes made to two components in the same commit do not necessarily indicate the co-evolution of the two. These changes could be completely unrelated. The study \cite{Yu2007} acknowledges the fact that evolutionary coupling could also be determined accidentally by two components changing in the same commit (independent evolution, as it is called) and this will bring noise to the measurement of evolutionary coupling. 


Zimmermann et al \cite{Zimmermann:2004:MVH:998675.999460} introduced data mining techniques to obtain association
rules from version histories.
The mined association rules  have a probabilistic interpretation based on the amount of
evidence in the transactions they are derived from. This
amount of evidence is determined by two measures: 
support and confidence.  They developed a tool to predict future or
missing changes.




In order to add logical dependencies besides structural dependencies as inputs for methods and tools for dependency management and analysis, class co-changes must be filtered until they remain only a reduced but relevant set of true logical dependencies. 


\section{Research questions}
\label{sec:question}

In this work, we explore several ways of filtering logical dependencies.  We identify following factors that could be used to filter logical dependencies: the maximum number of files in a commit accepted as logical dependencies, the minimum number of occurrences for a co-change to be considered a logical dependency, and accepting changes in comments as a source of logical dependencies. 

We will address the following research questions:

\textit{\textbf{Question 1}}. Which is the most frequent size for a commit transaction ?  

\textit{Motivation}: We calculate the size for a commit transaction as the total number of source code files that have changed. Even though the versioning systems best practices encourage developers to commit often which implies small size commit transactions, the size of the commit transaction relies also on the developers culture. We think that finding the most frequent size for a commit transaction could help into setting ranges for what is a normal size commit transaction for the systems. And also to set a target commit transaction group from which we can extract logical dependencies.

\textit{\textbf{Question 2}}.Is it necessary to set a threshold on the size of commit transactions which are considered to generate valid logical dependencies ?

\textit{Motivation}: A big commit transaction can indicate that a merge with another branch or a folder renaming has been made. In this case, a series of irrelevant logical dependencies can be introduced since not all the files are updated in the same time for a development reason. Different works have chosen fixed threshold values for the maximum number of files accepted in a commit. Cappiluppi and Ajienka, in their works \cite{DBLP:journals/jss/AjienkaC17}, \cite{DBLP:journals/ese/AjienkaCC18} only take into consideration commits with less then 10 source code files changed in building the logical dependencies. The research of Beck et al \cite{Beck:2011:CMC:2025113.2025162} only takes in consideration transactions with up to 25 files. The research \cite{Oliva:2011:ISL:2067853.2068086} provided also a quantitative analysis of the number of files per revision; Based on the analysis of  40,518 revisions, the mean value obtained for the number of files in a revision is 6 files. However, standard deviation value shows that the dispersion is high. Based on all these considerations, we will experiment with different values for the threshold value for the maximum number of files accepted in a commit. 



\textit{\textbf{Question 3}}. Considering changes which are only in comments as valid can lead to additional logical dependencies? How many logical dependencies are introduced by considering comment changes as valid changes and in what percentage can this influence the analysis?

\textit{Motivation}: Not all the commits that have source code files changed include real code changes, some of them can be only comments changes. We consider that there is probably no logical dependency between two classes that change in the same time only by comments changes. It could be that someone is adding implementation documentation or copyright or ownership information. Some studies have not considered this aspect, so we will analyse the impact of considering/not considering changes in  comments as valid logical dependencies. 


\textit{\textbf{Question 4}}. How many occurrences of a logical dependency are needed to consider it a \textit{valid} logical dependency ? 

\textit{Motivation}: One occurrence of a logical dependency between two classes can be a valid logical dependency, but can also be a coincidence. Taking into consideration only logical dependencies with multiple occurrences as valid dependencies can lead to more accurate logical dependencies and more accurate results. On the other hand, if the project studied has a relatively small amount of commits, the probability to find multiple updates of the same classes in the same time can be small, so filtering after the number of occurrences can lead to filtering all the logical dependencies extracted. Giving the fact that we will study multiple projects of different sizes and number of commits, we will analyze also the impact of this filtering on different projects.

\textit{\textbf{Question 5}}. How does filtering affect the overlap between structural and logical dependencies ? 

\textit{Motivation}: Traditional software engineering considers coupling as the cause for co-changes, thus logical and structural dependencies should present a very big overlap. However, in \cite{Oliva:2011:ISL:2067853.2068086} and \cite{DBLP:journals/jss/AjienkaC17} has been experimentally determined that a very large number of logical dependencies are outside the intersection with structural dependencies. We will investigate the influence of different filtering degrees on the intersections between logical and structural dependencies.  





\section{Tool for measuring software dependencies}
\label{sec:tool}

In order to build structural and logical dependencies we have developed a tool that takes as input the source code repository and builds the required software dependencies. The workflow can be delimited by three major steps as it follows (Figure \ref{fig:fig3}):\\ \\
\textit{\textbf{Step 1:} Extracting structural dependencies.}\\
\textit{\textbf{Step 2:} Extracting logical dependencies.}\\
\textit{\textbf{Step 3:} Processing the information extracted.}



\begin{figure*}[htb]
\centering
\includegraphics[width=\textwidth]{fig3.png}
\caption{Processing phases}
\label{fig:fig3}
\end{figure*}

\subsection{ Extracting structural dependencies}

%Even though in some of the cases if class A depends on class B, changes in class B can produce changes in class A, but not the other way around \cite{Yu2007}. There are some cases in which if class A depends on class B,  changes in class B can produce changes in class A and viceversa. So we will consider structural dependencies as bidirectional relationships, "class A depends on class B" and "class B depends on class A". The choice of building bidirectional relationships is also motivated by the fact that we cannot establish for the moment the direction of the logical dependencies of the system. So in order to have a omogenity between the logical and structural dependencies analysis results, we will take both of the relationships types as bidirectional.
A structural dependency between two classes A and B is given by the fact that A statically depends on B, meaning that A cannot be compiled without knowing about B. In object oriented system, this dependency can be given by many types of relationships between the two classes: A extends B, A implements B, A has attributes of type B, A has methods which have type B in their signature, A uses local variables of type B, A calls methods of B.


 We use an external tool called srcML \cite{2003:XLC:851042.857028},
\cite{Collard:2011:LTF:2067850.2068011} to convert all source code files from the current release into XMl files. All the information about classes, methods, calls to other classes are afterwards extracted by our tool parsing the XML files and building a dependencies data structure. We have chosen to rely on srcML as a preprocessing tool because it reduces a significant number of syntactic differences from different programming languages and can make easyer the parsing of source code written in different programming languages such as Java, C++ and C\#.    

\subsection{Extracting logical dependencies}

The versioning system contains the long-term change history of every file. Each project change made by an individual at a certain point of time is contained into a commit \cite{svn}. All the commits are stored in the versioning system chronologically and each commit has a parent. The parent commit is the baseline from which development began, the only exception to this rule is the first commit which has no parent. We will take into consideration only \textit{commits that have a parent} since the first commit can include source code files that are already in development (migration from one versioning system to another) and this can introduce redundant logical links \cite{DBLP:journals/jss/AjienkaC17}. 

The tool looks through the main branch of the project and gets all the existing commits. For each commit a diff against the parent will be made and stored. Here we have the option to ignore commits that contain more files than a threshold value for commit size. Also, we have the option to check whether the differences are in actual code or if they affect only parts of source files that are only comments.  Finally after all the difference files are stored, all the files are parsed and logical dependencies are build. For a group of files that are committed together, logical dependencies are added between all pairs formed by members of the group. Adding a logical dependency increases an occurrence counter for the logical link. 

\section{Experimental results}
\label{sec:experiments}


We have analysed a set of open-source projects found on GitHub\footnote{http://github.com/} \cite{Kalliamvakou2016} in order to extract the structural and logical dependencies between classes. Table \ref{table:1} enumerates all the systems studied. The 1st column assigns the projects IDs; 2nd column shows the project name; 3rd column shows the number of entities(classes and interfaces) extracted; 4th column shows the number of most recent commits analysed from the active branch of each project and the 5th shows the language in which the project was developed.
\begin{table}[!h]
\caption{Summary of open source projects studied.}
\label{table:1}
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
   ID  & Project    & Nr. of & Nr. of& Type\\
     &     & entites & commits & \\
\hline
1	&	bluecove	&	586	&	894	&	java	\\
2	&	aima-java	&	987	&	818	&	java	\\
3	&	powermock	&	1084	&	893	&	java	\\
4	&	restfb	&	783	&	1188	&	java	\\
5	&	rxjava	&	2673	&	2468	&	java	\\
6	&	metro-jax-ws	&	1103	&	2222	&	java	\\
7	&	mockito	&	1409	&	1572	&	java	\\
8	&	grizzly	&	1592	&	3122	&	java	\\
9	&	shipkit	&	242	&	1483	&	java	\\
10	&	OpenClinica	&	1653	&	3749	&	java	\\
11	&	robolectric	&	2050	&	5029	&	java	\\
12	&	aeron	&	541	&	5101	&	java	\\
13	&	antlr4	&	1381	&	3449	&	java	\\
14	&	mcidasv	&	805	&	3668	&	java	\\
15	&	ShareX	&	919	&	2505	&	csharp	\\
16	&	aspnetboilerplate	&	2353	&	1615	&	csharp	\\
17	&	orleans	&	3485	&	3353	&	csharp	\\
18	&	cli	&	767	&	2397	&	csharp	\\
19	&	cake	&	2250	&	1853	&	csharp	\\
20	&	Avalonia	&	1677	&	2445	&	csharp	\\
21	&	EntityFramework	&	7107	&	2443	&	csharp	\\
22	&	jellyfin	&	2179	&	4065	&	csharp	\\
23	&	PowerShell	&	861	&	2033	&	csharp	\\
24	&	WeiXinMPSDK	&	2029	&	2723	&	csharp	\\
25	&	ArchiSteamFarm	&	117	&	2181	&	csharp	\\
26	&	VisualStudio	&	1016	&	4417	&	csharp	\\
27	&	CppSharp	&	259	&	3882	&	csharp	\\
\hline
\end{tabular}
\end{table}


In a first experiment, we determined the commit sizes $cs$ for all commit transactions for all projects and grouped them into 4 categories: small transactions (ST), when 	$cs\leq 5$; medium transactions (MT), when 	$5 < cs\leq 10$; large transactions (LT), when 	$10 < cs\leq 20$; and very large transactions (VLT), when 	$20 < cs$. The results are presented in Tables \ref{table:5} and \ref{table:6}.

In the main series of experiments, for each system, we extracted its structural dependencies, its logical dependencies and determined the overlap between the two dependencies sets, in various experimental conditions. 

One variable experimental condition is whether changes located in comments contribute towards logical dependencies. This condition distinguishes between two different cases: 
\begin{itemize}
	\item with comments: a change in source code files is counted towards a logical dependency, even if the change is inside comments in all files
	\item without comments: commits that changed source code files only by editing comments are ignored as logical dependencies
\end{itemize}

In all cases, we varied the following threshold values: 
 \begin{itemize}
	\item commit size ($cs$): the maximum number of files allowed in a commit to be counted as logical dependency. The values for this threshold were 5, 10, 20 and no threshold (infinity).  
	\item number of occurrences ($occ$): the minimum number of repeated occurrences for a co-change to be counted as logical dependency. The values for this threshold were 1, 2, 3 and 4.  
\end{itemize}

The six tables below present the synthesis of our experiments. 
We have computed the following  values:
\begin{itemize}
	\item the mean ratio of the number of logical dependencies  (LD) to the number of structural dependencies (SD)
   \item the mean percentage of structural dependencies that are also logical dependencies (calculated from the number of overlaps divided to the number of structural dependencies)	
		\item the mean percentage of logical dependencies that are also structural dependencies (calculated from the number of overlaps divided to the number of logical dependencies)
\end{itemize}

In all the six tables, \ref{tab:ratio:comm}, \ref{tab:ratio:nocomm}, \ref{tab:percSD:comm}, \ref{tab:percSD:nocomm},
\ref{tab:percLD:comm}, \ref{tab:percLD:nocomm} we have on columns the values used for the commit size $cs$, while on rows we have the values for the number of occurrences threshold $occ$. The tables contain median values obtained for experiments done under all combinations of the two threshold values, on all test systems. In all tables, the upper right corner corresponds to the most relaxed conditions, while the lower left corner corresponds to the most restrictive conditions.


\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1.25}
\caption{Ratio of number of LD to number of SD, case with comments}
\label{tab:ratio:comm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs<\infty$	\\
\hline
$occ\geq 1$	&	8.02	&	17.22	&	33.19	&	314.6	\\
$occ\geq 2$	&	4.05	&	8.90	&	16.24	&	274.6	\\
$occ\geq 3$	&	2.57	&	5.04	&	9.92	&	200.87	\\
$occ\geq 4$	&	1.81	&	3.39	&	6.19	&	134.8	\\
\hline
\end{tabular}
\end{table}


\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1.25}
\caption{Ratio of number of LD to number of SD, case without comments}
\label{tab:ratio:nocomm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	7.85	&	16.33	&	29.78	&	306.54	\\
$occ\geq 2$	&	3.93	&	7.78	&	15.65	&	246.08	\\
$occ\geq 3$	&	2.42	&	4.91	&	8.19	&	115.56	\\
$occ\geq 4$	&	1.64	&	3.19	&	5.47	&	51.77	\\

\hline
\end{tabular}
\end{table}


\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1.25}
\caption{Percentage of SD that are also LD, case with comments}
\label{tab:percSD:comm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	17.11	&	25.69	&	37.94	&	78.11	\\
$occ\geq 2$	&	9.74	&	15.52	&	25.14	&	68.32	\\
$occ\geq 3$	&	5.92	&	10.6	&	17.75	&	63.6	\\
$occ\geq 4$	&	4.87	&	8.45	&	13.72	&	56.52	\\
\hline
\end{tabular}
\end{table}


\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1.25}
\caption{Percentage of SD that are also LD, case without comments}
\label{tab:percSD:nocomm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	16.56	&	24.77	&	37.33	&	75.98	\\
$occ\geq 2$	&	9.03	&	15.2	&	23.85	&	61.66	\\
$occ\geq 3$	&	5.92	&	10.6	&	15.81	&	49.03	\\
$occ\geq 4$	&	4.59	&	7.41	&	11.85	&	37.53	\\
\hline
\end{tabular}
\end{table}


\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1.25}
\caption{Percentage of LD that are also SD, case with comments}
\label{tab:percLD:comm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	1.62	&	1.26	&	1.06	&	0.24	\\
$occ\geq 2$	&	2.72	&	1.95	&	1.58	&	0.31	\\
$occ\geq 3$	&	3.94	&	2.27	&	1.71	&	0.33	\\
$occ\geq 4$	&	4.66	&	2.76	&	2.42	&	0.41	\\
\hline
\end{tabular}
\end{table}


\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1.25}
\caption{Percentage of LD that are also SD, case without comments}
\label{tab:percLD:nocomm}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	1.62	&	1.47	&	1.15	&	0.28	\\
$occ\geq 2$	&	2.72	&	2.1	&	1.7	&	0.31	\\
$occ\geq 3$	&	3.63	&	2.38	&	2.3	&	0.35	\\
$occ\geq 4$	&	4.66	&	2.62	&	2.34	&	0.53	\\
\hline
\end{tabular}
\end{table}



\begin{table}[!h]
\renewcommand{\arraystretch}{1.25}
\caption{The distribution of commit size in percentage relative to the total number of commits of the system }
\label{table:5}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
   &	ST	&	 MT	&	LT	&	VLT	\\
\hline
1	&	82.55	&	10.85	&	4.14	&	2.46	\\
2	&	71.39	&	13.08	&	7.82	&	7.7	\\
3	&	73.91	&	13.33	&	6.27	&	6.49	\\
4	&	84.51	&	8.5	&	3.11	&	3.87	\\
5	&	75.2	&	11.26	&	5.92	&	7.62	\\
6	&	87.8	&	6.35	&	2.57	&	3.29	\\
7	&	78.18	&	11.96	&	5.73	&	4.13	\\
8	&	79.63	&	9.67	&	5.77	&	4.93	\\
9	&	83.82	&	9.58	&	4.18	&	2.43	\\
10	&	82.58	&	9.66	&	5.31	&	2.45	\\
11	&	82.96	&	8.55	&	4.89	&	3.6	\\
12	&	87.69	&	8.51	&	2.96	&	0.84	\\
13	&	81.19	&	8.23	&	5.54	&	5.03	\\
14	&	96.7	&	1.94	&	0.71	&	0.65	\\
15	&	89.27	&	7.11	&	2.17	&	1.45	\\
16	&	77.28	&	12.76	&	5.51	&	4.46	\\
17	&	70.3	&	12.53	&	9.48	&	7.69	\\
18	&	73.93	&	12.27	&	6.63	&	7.18	\\
19	&	69.99	&	14.41	&	6.91	&	8.69	\\
20	&	68.79	&	10.1	&	7.44	&	13.66	\\
21	&	60.66	&	17.63	&	10.04	&	11.66	\\
22	&	73.97	&	12.63	&	6.94	&	6.47	\\
23	&	83.13	&	6.64	&	4.18	&	6.05	\\
24	&	79.43	&	8.56	&	5.66	&	6.35	\\
25	&	94.54	&	3.62	&	1.1	&	0.73	\\
26	&	76.21	&	9.74	&	5.84	&	8.22	\\
27	&	86.17	&	8.53	&	4.12	&	1.18	\\
\hline
Avg	&	79.7	&	9.93	&	5.22	&	5.16	\\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\renewcommand{\arraystretch}{1.25}
\caption{Percentage of LD extracted from different commit size chunks relative to the total number of LD of the system }
\label{table:6}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
   &	ST	&	MT	&	LT	&	VLT	\\
\hline
1	&	10.1	&	2.72	&	4.08	&	83.11	\\
2	&	1.77	&	1.9	&	3.55	&	92.78	\\
3	&	4.07	&	5.09	&	5.98	&	84.87	\\
4	&	31.56	&	7.63	&	24.68	&	36.13	\\
5	&	0.52	&	1.98	&	2.15	&	95.35	\\
6	&	0.47	&	0.24	&	0.5	&	98.8	\\
7	&	1.59	&	1.81	&	2.56	&	94.04	\\
8	&	1.54	&	2.03	&	3.76	&	92.67	\\
9	&	8.15	&	7.83	&	11.85	&	72.17	\\
10	&	1.52	&	2.06	&	2.49	&	93.92	\\
11	&	7.28	&	8.23	&	13.72	&	70.76	\\
12	&	23.71	&	21.08	&	19.93	&	35.28	\\
13	&	10.79	&	20.4	&	7.9	&	60.91	\\
14	&	2.12	&	0.91	&	1.3	&	95.67	\\
15	&	1.42	&	1.29	&	2.13	&	95.16	\\
16	&	2.21	&	2.52	&	3.12	&	92.16	\\
17	&	1.59	&	1.9	&	4.66	&	91.86	\\
18	&	2.41	&	3.58	&	6.63	&	87.38	\\
19	&	0.61	&	0.69	&	1.54	&	97.16	\\
20	&	0.54	&	0.79	&	1.56	&	97.11	\\
21	&	0.96	&	0.93	&	45.01	&	53.1	\\
22	&	2.06	&	3.96	&	5.81	&	88.18	\\
23	&	1.28	&	1.26	&	1.03	&	96.44	\\
24	&	0.82	&	0.79	&	1.67	&	96.73	\\
25	&	41.28	&	17.22	&	9.06	&	32.44	\\
26	&	2.75	&	3.07	&	6.49	&	87.69	\\
27	&	25.16	&	18.52	&	23.65	&	32.67	\\

\hline
Avg	&	6.97	&	5.2	&	8.03	&	79.8	\\
\hline
\end{tabular}
\end{table}



\section{Discussion}
\label{sec:discussion}


This section uses the experimental results to answer the research questions outlined in section \ref{sec:question}.


\textit{\textbf{Question 1}}. Which is the most frequent size for a commit transaction ?  

Table \ref{table:5} presents the size distribution for commit transactions in percentage relative to the total number of commits for each system presented in table \ref{table:1}.The average percentage for commit transactions with less than 5 source code files is 79.7\%, on the opposite side are commit transactions with more than 20 source code files which have an average percentage of 5.16\%. Based on the results we can say that the majority of the commit transactions have no more than 5 source code files.

\textit{\textbf{Question 2}}. Is it necessary to set a threshold on the size of commit transactions which are considered to generate valid logical dependencies ?
Logical dependencies are generated for all pairs of classes which have changed in the same commit transaction. The number of logical dependencies generated from a commit transaction is proportional with the square of the number of participating classes.  Table \ref{table:6} presents how many logical dependencies are extracted from commit transactions of different sizes. 
Based on the results from Table \ref{table:6} and Table \ref{table:5} we identify that a small amount of commits as in the case of commit transactions with more than 20 source code files can lead to a vast amount of logical dependencies.  
The commit transactions with less than 5 files, which are the most frequent types of commits, produce in average only 6.97\% of the total logical dependencies extracted from the systems. But big commit transactions can be caused by development branches merge into the main branch, in this case the commit transaction is actually the sum of many other commit transactions made into a different branch and we cannot consider them as one single commit and definitely we cannot consider the logical dependencies extracted as valid logical dependencies. So a threshold to filter this kind of commit transactions is required.

Based on the results presented in Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm}, the number 
of changed files taken into consideration has an important influence over the ratio of the number  of 
logical dependencies to the number of structural dependencies.  If no threshold is set for the number of files in a commit (the cases in the last column in Tables \ref{tab:ratio:comm} and 
\ref{tab:ratio:nocomm} ) then the number of logical dependencies outnumbers the structural dependencies with a factor of up to 314. The maximum factor is measured in the case when no filtering is done on the number of occurrences (first row).  
In this case, we can not talk about logical dependencies, but about classes that happened to once change in the same time, by various reasons. The number of pairs of classes that happen to once change in the same time is up to 300 times bigger than the number of pairs of classes presenting structural dependencies.
%Tables \ref{table:5} and \ref{table:6}  present the detailed situation of the number of logical dependencies, under the conditions of a varying threshold for the number of files accepted in a commit, without any filtering according to the number of occurrences, for all test systems. These tables detail the situations summarized in the 1st rows of tables \ref{tab:ratio:comm} and respectively \ref{tab:ratio:nocomm}. 

When filtering is done according to conditions on the number of occurrences, we observe in Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm} that the values on the last column still do not fall below 51. This number is still too big to accept for logical dependencies.  It is clear that it is necessary to  put a threshold on the number of files accepted in a commit in order to filter out noise.


If we refer to the overlap between structural and logical dependencies, we can see in Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm} that the percentage of structural dependencies which are also logical dependencies is as well affected by setting a threshold on the number of files accepted in a commit. Setting a threshold leads to a smaller number of logical dependencies overall and this is what affects also the smaller number of structural dependencies that are also logical dependencies. However, we can see that the percentage of dependencies in the overlap decreases much slower than the total number of logical dependencies. For example, when setting  the $cs$ threshold at 10, we see in Table \ref{tab:ratio:comm} that the total number of logical dependencies decreases approx 20 times compared with no threshold. In the same time, we can see in Table \ref{tab:percSD:comm}  that the overlap between the logical and structural dependencies decreases less, only approx 3 times. This confirms the fact that the logical dependencies filtered out were not true dependencies. It is clear that setting a threshold on the maximum number of files accepted in a commit is essential for the quality of finding true logical dependencies.


\textit{\textbf{Question 3}}. Considering changes only in comments as valid can lead to additional logical dependencies? How many logical dependencies are introduced by considering comment changes as valid changes and in what percentage this can influence the analysis?

In order to assess the influence of comments, we compare pairwise Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm},  
Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm} and Tables \ref{tab:percLD:comm} and \ref{tab:percLD:nocomm}. 
We observe that, although there are some differences between pairs of measurements done in similar conditions with and without comments, the differences are not significant.

In the case of the ratio of the number of logical dependencies to the number of structural dependencies, from Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm} we can see that the maximum difference is for the values from the position of the first row, last column. Without comments, the value of the ratio is 306.54, compared to the value with comments which is 314.6. The decrease represents less than 3\% of the value with comments. In the case of the percentage of structural dependencies that are also logical dependencies, from Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm}, we can see that the maximum difference is also for the values from the first row, last column. Without comments, the overlap is 75.98, compared to the value with comments which is 78.11.  The decrease represents also less than 3\% of the value with comments. We notice that the differences between the two cases are very small. %decrease percentage is smaller for the overlap than for the ratio of the total number of logical dependencies, thus we can say that eliminating changes due only to comments can slightly improve the quality of finding logical dependencies. 



\textit{\textbf{Question 4}}. How many occurrences of a logical dependency are needed to consider it a \textit{valid} logical dependency ? 

If we look at consecutive rows in Table \ref{tab:ratio:comm} or in Table \ref{tab:ratio:nocomm}, corresponding to increased threshold values for the number of occurrences, we can roughly say that  increasing by 1 the occurrence threshold while maintaining the other conditions reduces with more than half the total number of logical dependencies.  

In order to find the appropriate level of filtering out false logical dependencies, we assume as a rule of thumb that the number of logical dependencies should be not bigger that the number of structural dependencies. Choosing the most restrictive combination of thresholds (a commit size threshold of 5 files combined with an occurrence threshold of 4) leads to a number of logical dependencies which comes near to the number of structural dependencies.

%In tables \ref{tab:ratio:comm} or \ref{tab:ratio:nocomm}, we can see that we can obtain a number of logical dependencies which is between one quarter and one third of the number of the structural dependencies either by setting a commit size threshold of 5 files combined with an occurrence threshold of 2, or a commit size threshold of 10 files combined with an occurrence threshold of 3, or a commit size threshold of 20 files combined with an occurrence threshold of 4.  It is clear that increasing the threshold value for number of occurrences can be done only together with increasing the threshold value for maximum number of committed files. A more complex filtering condition can aggregate the 3 simple filtering cases, in the form: $((cs\leq 5) and (occ\geq 2)) or ((cs\leq 10) and (occ\geq 3)) or ((cs\leq 20) and (occ\geq 4))$. In this condition, $occ$ refers actually to 3 different counters, because every filtering on a different $cs$ has its own counter.  


\textit{\textbf{Question 5}}. How does filtering affect the overlap between structural and logical dependencies ? 

The overlap between structural and logical dependencies is given by the number of pairs of classes that have both structural and logical dependencies. We evaluate this overlap as a percentage relative to the number of structural dependencies in Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm}, respectively as  a percentage relative to the number of logical dependencies in Tables \ref{tab:percLD:comm} and \ref{tab:percLD:nocomm}.

A first observation from Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm} is that not all pairs of classes with structural dependencies co-change. The biggest value for the percentage of structural dependencies that are also logical dependencies is 78.11\% obtained in the case when no filterings are done.  Tables \ref{table:10} and \ref{table:11} relate with Table \ref{tab:percSD:comm} as they detail information about overlaps between logical and structural dependencies. Table \ref{table:10} gives details about the cases summarized in the first column, while Table \ref{table:11} gives details about the cases summarized in the last column of Table \ref{tab:percSD:comm}. 
We can see in Table \ref{table:11} that only in case of a single project (with project ID 25) we record the existence of co-changes for all pairs of classes that have structural dependencies. This is an indicator for the design quality of the analysed projects. 
%Looking at the detailed tables, we can notice that the values for individual projects may present significant differences from the median. For smaller projects, such as projects with IDs 1, 3, 4, the filtering can lead to loosing logical dependencies.  

From Tables \ref{tab:percLD:comm} and \ref{tab:percLD:nocomm} we notice that the percentage of logical dependencies which are also structural is always low to very low. This means that most co-changes are recorded between classes that have no structural dependencies to each other.   
 
\begin{table}[!h]
\renewcommand{\arraystretch}{1.25}
\caption{Percentage of SD that are also LD,  when $cs \leq 5$, for different threshold values for $occ$}
\label{table:10}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
    ID  & $occ\geq 1$ & $occ\geq 2$ & $occ\geq 3$ & $occ\geq 4$  \\
\hline
1	&	18,48	&	9,74	&	5,73	&	4,87	\\
2	&	9,52	&	4,31	&	2,13	&	1,82	\\
3	&	19,92	&	8,79	&	4,67	&	2,75	\\
4	&	53,69	&	43,14	&	28,38	&	26,05	\\
5	&	9,17	&	6,16	&	3,31	&	2,31	\\
6	&	12,57	&	8,66	&	5,31	&	4,33	\\
7	&	18,77	&	13,65	&	9,34	&	6,9	\\
8	&	19,97	&	11,94	&	7,94	&	5,87	\\
9	&	53,85	&	40,11	&	24,73	&	17,58	\\
10	&	8,03	&	5,45	&	3,15	&	2,27	\\
11	&	40,93	&	31,37	&	25,68	&	21,97	\\
12	&	35,91	&	24,66	&	17,88	&	13,49	\\
13	&	17,11	&	10,79	&	7,5	&	5,88	\\
14	&	39,87	&	28,6	&	18,67	&	15,31	\\
15	&	16,27	&	6,44	&	3,73	&	3,39	\\
16	&	14,8	&	7,85	&	4,25	&	3,27	\\
17	&	10,33	&	5,19	&	3,1	&	2,36	\\
18	&	3,86	&	2,15	&	0,86	&	0	\\
19	&	3,55	&	2,43	&	0,93	&	0,75	\\
20	&	14,78	&	8,09	&	4,46	&	3,63	\\
21	&	16,56	&	10,67	&	5,92	&	4,59	\\
22	&	9,5	&	5,72	&	3,17	&	1,43	\\
23	&	21,76	&	16,79	&	14,89	&	13,36	\\
24	&	10,72	&	8,56	&	7,11	&	6,08	\\
25	&	62,5	&	62,5	&	62,5	&	62,5	\\
26	&	25,14	&	18,78	&	14,92	&	11,33	\\
27	&	51,3	&	30,43	&	26,96	&	24,35	\\
\hline
M	&	17,10&	9,74	&	5,92	&	4,87	\\

\hline
\end{tabular}
\end{table}



\begin{table}[!h]
\renewcommand{\arraystretch}{1.25}
\caption{Percentage of SD that are also LD,  when  $cs< \infty$, for different threshold values for $occ$ }
\label{table:11}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
    ID  & $occ\geq 1$ & $occ\geq 2$ & $occ\geq 3$ & $occ\geq 4$  \\
\hline
1	&	77,51	&	54,44	&	46,7	&	31,38	\\
2	&	82,44	&	55,71	&	32,06	&	20,94	\\
3	&	71,02	&	50	&	32,28	&	24,18	\\
4	&	98,52	&	90,93	&	87,55	&	86,18	\\
5	&	91,55	&	81,06	&	72,8	&	65,17	\\
6	&	91,06	&	84,78	&	75,7	&	65,78	\\
7	&	87,73	&	68,24	&	49,63	&	35,66	\\
8	&	97,57	&	96,42	&	77,85	&	65,26	\\
9	&	90,66	&	87,91	&	80,77	&	73,63	\\
10	&	29,1	&	22,96	&	17,6	&	13,29	\\
11	&	72,68	&	64,48	&	56,17	&	49,67	\\
12	&	70,07	&	59,22	&	47,73	&	37,35	\\
13	&	56,56	&	46,9	&	40,26	&	33,94	\\
14	&	97,73	&	95,04	&	94,2	&	85,95	\\
15	&	97,63	&	95,93	&	94,24	&	64,41	\\
16	&	46,03	&	39,33	&	28,21	&	20,61	\\
17	&	72,64	&	51,02	&	37,69	&	30,3	\\
18	&	78,11	&	75,54	&	67,81	&	53,65	\\
19	&	93,08	&	91,4	&	88,22	&	80,56	\\
20	&	71,13	&	65,97	&	63,6	&	59,83	\\
21	&	77,09	&	54,96	&	41,43	&	32,33	\\
22	&	52,71	&	51,48	&	35,14	&	31,36	\\
23	&	98,09	&	90,08	&	86,26	&	69,08	\\
24	&	77,63	&	75,88	&	65,57	&	63,81	\\
25	&	100	&	100	&	100	&	100	\\
26	&	71,82	&	67,4	&	67,4	&	65,19	\\
27	&	80,87	&	68,7	&	59,13	&	56,52	\\
\hline
M	&	78,11&	68,23	&	63,59	&	56,52	\\
\hline
\end{tabular}
\end{table}




In order to present overlaps between structural and logical dependencies we will use Venn diagrams, used for this purpose also in \cite{Oliva:2011:ISL:2067853.2068086} and \cite{DBLP:journals/jss/AjienkaC17}.In Figure \ref{fig_venn} we present the intersections of logical and structural dependencies, in two relevant cases.In both cases, the left circle, which is of constant size, represents the set of structural dependencies.The right circle represents the logical dependencies and its area is proportional with the number of logical dependencies. Both are cases without comments.

In Figure \ref{fig_venn}, case a.) which corresponds to no filtering, the number of logical dependencies is bigger than the number of structural dependencies by a factor of 314. In this case, we also have the biggest percentage of structural dependencies which are also co-changing as logical dependencies (78\%). %This case shows that classes with structural dependencies change together more often, but these changes cannot be yet considered logical dependencies.

In Figure \ref{fig_venn}, case b.) corresponding to the highest level of filtering, the number of logical dependencies is only slightly bigger than the number of structural dependencies by a factor of 1.8. In this case, the percentage of structural dependencies which are also logical is small, as well as the percentage of logical dependencies that are also structural.  The percentage of logical dependencies that are also structural is 4.66\% in this case. The percentage of logical dependencies that are not structural is 95.34\%, and we consider that they deserve to be considered as additional dependencies.
We consider that this may be the optimal level of filtering. 
%is given by threshold combinations such as in cases c.), d.) and e.).  In the case d.) the number of logical dependencies represents one third of the number of structural dependencies. 

The percentage of structural dependencies which are also logical is 4.87\%,  while the percentage of logical dependencies that are also structural is 4.66\%. We can see that a percentage of 95.34\% of logical dependencies do not correspond with structural dependencies, while 95.13\% of the structural dependencies are not doubled by logical dependencies. These percentages are statistically similar with the values obtained in \cite{Oliva:2011:ISL:2067853.2068086}: they measured LCOP (Logical Coupling Only Percentage)  and SCOP (Structural Coupling Only Percentage) and obtained 95\% for SCOP and 91\% for LCOP. 

In \cite{DBLP:journals/jss/AjienkaC17} the authors measured CSD (Co-changes Structural Dependencies ratio) and the CLD (Coupled Logical Dependencies ratio) and obtained the values for CSD about 80\% and CLD about 15\%.  Also in case of \cite{DBLP:journals/jss/AjienkaC17}  the total number of logical dependencies is 10 times bigger than the number of structural dependencies, while in our work, in the case considered of optimal filtering,  the total number of logical dependencies can be approximated with the number of structural dependencies. The explanation for this difference lies in the different manner of determining the logical dependencies: while \cite{DBLP:journals/jss/AjienkaC17} also uses a threshold of 10 for the maximum number of files in a commit, they count all co-changes toward logical dependencies, although they assign them different strengths. This would correspond to the filtering case determined by the combination: the commit size threshold is 10 files and the occurrence threshold is 1. 


\begin{figure*}[!t]
\centering
\includegraphics[width=5.7in]{figvenn-new.pdf}
\vspace{-1cm}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
\caption{Intersections of logical and structural dependencies, in different cases defined by different combinations of filtering thresholds. }
\label{fig_venn}
\end{figure*}





\section {Threats to validity}
\label{sec:validity}


An issue which has not been investigated enough is whether the reduced set of logical dependencies obtained after filtering contains indeed true logical dependencies. This could be done by manual inspection of the classes in order to validate the reported logical dependencies by the opinion of a human expert. Unfortunately doing such manual validation for all case studies is an impossibly huge task. We have manually inspected the code and code changes from a few of the case studies and the results seem promising. For example, in the case of the project selma, when filtering with both thresholds on commit size and number of occurrences, the tool reduced the initial set of 4751 co-change links identified between classes when no filtering was done, to a number of just 25 logical dependencies. Out of these 25 logical dependencies, 5 are doubled by structural dependencies. From the 20 remaining logical dependencies identified by the tool, we determined by manual inspection that 18 are logical, while for 2 of them we could not see a logical reason for a dependency relationship. 
The 18 class pairs where we could confirm by manual inspection a logical link are: ('FieldItem', 'MapperMethodGenerator'),  ('CollectionsMapperIT', 'MappingBuilder'), ('MapperMethodGenerator', 'MethodWrapper'), ('MapperMethodGenerator', 'MappingSourceNode'),  ('MapperMethodGenerator', 'MappingBuilder'), ('MapperMethodGenerator', 'BeanWrapper'), ('MapperMethodGenerator', 'InOutType'), ('MapperMethodGenerator', 'FailingMappersIT'),  ('MapperMethodGenerator', 'FailingMissingPropertyMapsMappersIT'), ('MapperMethodGenerator', 'MapperWrapper'), ('MapperMethodGenerator', 'MappingRegistry'),  ('CustomMapperWrapper', 'FactoryWrapper'),  ('CustomMapperWrapper', 'MappingBuilder'),  ('CustomMapperWrapper', 'MapperClassGenerator'), ('MappingRegistry', 'MapperClassGenerator'), ('InOutType', 'MappingBuilder'),  ('MappingBuilder', 'MappingSourceNode'),  ('FactoryWrapper', 'MapperClassGenerator').

We consider that in the future, the validation of extracted logical dependencies will occur by using them to enhance dependency graphs for  applications such as architectural reconstruction through clustering \cite{SoraConti} or finding of key classes \cite{PagerankENASE}, and evaluating the positive impact on their results.   


As we could see in Tables \ref{tab:percLD:comm} and \ref{tab:percLD:nocomm}, only a small amount of logical dependencies are between classes that also present structural dependencies.  In our experiments, even after filtering, around 95\% of the logical dependencies are between classes without structural dependencies. Although this big percentage is supported also by experiments of related works, we consider that future work must further investigate its cause. One possible cause could be that some of the co-changes were legit logical dependencies at some moment in the past, maybe even doubled by structural dependencies in previous revisions, but in the mean time the problem causing them may have been refactored and they should not be added to the dependency model of the current system.  

In this work we have extracted logical dependencies from all the revisions of the system, and structural dependencies from the last revision of the system. In future work we will take into account also structural dependencies from all the revisions of the system, in order to filter out the old, out-of-date logical dependencies.  Some logical dependencies may have been also structural in previous revisions of the system but not in the current one. If we take into consideration also structural dependencies from previous revisions then the overlapping rate between logical and structural dependencies could probably increase. Another way to investigate this problem could be to study the trend of occurrencies of co-changes: if co-changes between a pair of classes used to happen more often in the remote past than in the more recent past, it may be a sign that the problem causing the logical coupling has been removed in the mean time. 


   


\section{Conclusion}
\label{sec:Conclusion}
   
In this work we experimentally define methods to filter out the most relevant logical dependencies from co-changing classes. 

Regarding whether co-changes which affect only comments contribute to logical dependencies, our study has found out that when ignoring commits which change only comments in source files, the quality of logical dependencies is slightly improved.

Our experiments show that the most important factors which affect the quality of logical dependencies are: the maximum number of files allowed in a commit to be counted as logical dependency, and the minimum number of repeated occurrences for a co-change to be counted as logical dependency. 


 
\bibliographystyle{apalike}
{\small
\bibliography{logicaldepd}}
 

\end{document}

